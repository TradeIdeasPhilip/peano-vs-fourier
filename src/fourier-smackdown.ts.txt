import {
  AnimationLoop,
  getById,
  querySelector,
  querySelectorAll,
} from "phil-lib/client-misc";
import {
  Complex,
  FourierTerm,
  hasFixedContribution,
  samplesFromPath,
  samplesToFourier,
  termsToParametricFunction,
} from "./fourier-shared";
import { PathBuilder, PathCaliper, PathShape } from "./path-shape";
import {
  assertClass,
  assertNonNullable,
  count,
  FULL_CIRCLE,
  initializedArray,
  LinearFunction,
  makeBoundedLinear,
  makeLinear,
  parseFloatX,
  positiveModulo,
  Random,
  ReadOnlyRect,
  zip,
} from "phil-lib/misc";
import { ease, getMod } from "./utility";
import { resizeFont } from "./letters-base";
import { roundCursiveFont } from "./hershey-fonts/hershey-fonts";
import { LetterLayoutInfo, TextLayout } from "./letters-more";

// Background full of stars
{
  const random = Random.fromString("Pastel 41");
  const original = querySelector("[data-favorite]", SVGCircleElement);
  const getR = makeLinear(0, 0.025, 2, 0.15);
  for (let i = 0; i < 150; i++) {
    const copy = assertClass(original.cloneNode(true), SVGCircleElement);
    copy.cx.baseVal.value = random() * 16;
    copy.cy.baseVal.value = random() * 9;
    copy.r.baseVal.value = getR(random() + random());
    original.parentElement!.append(copy);
  }
}

const numberOfFourierSamples = 1024;

class MotionBlurSpinner {
  static readonly #parent = querySelector(
    "[data-motion-blur-spinners]",
    HTMLDivElement
  );
  #style: CSSStyleDeclaration;
  constructor(
    options: {
      radius: number;
      centerX: number;
      centerY: number;
      color?: string;
    } = { radius: 1, centerX: 2, centerY: 2 }
  ) {
    const element: HTMLDivElement = document.createElement("div");
    element.classList.add("motion-blur-spinner");
    MotionBlurSpinner.#parent.append(element);
    const style = (this.#style = element.style);
    style.setProperty("--radius", options.radius.toString());
    style.setProperty("--center-x", options.centerX.toString());
    style.setProperty("--center-y", options.centerY.toString());
    if (options.color) {
      style.setProperty("--color", options.color);
    }
    this.hide();
  }
  /**
   * TODO This breaks all of my rules.
   * But it will be a pain to do it right.
   * The rest of this is stateless.
   * You can call showFrame(n) at any time and get the same result.
   */
  #previousMain: number | undefined;
  showRadians(main: number) {
    const blur = this.#previousMain ?? main;
    this.#previousMain = main;
    const style = this.#style;
    style.display = "";
    style.setProperty("--main-angle", `${main}rad`);
    style.setProperty("--blur-angle", `${blur}rad`);
  }
  hide() {
    this.#previousMain = undefined;
    this.#style.display = "none";
  }
}

class Timer {
  #remainderToT: LinearFunction;
  readonly endTime: number;
  constructor(
    private readonly stepCount: number,
    private readonly period: number,
    startTime = 0,
    endTime = period - startTime
  ) {
    this.#remainderToT = makeBoundedLinear(startTime, 0, endTime, 1);
    this.endTime = period * stepCount;
  }
  get(timeInMs: number) {
    let index = Math.floor(timeInMs / this.period);
    let remainder: number;
    if (index < 0) {
      index = 0;
      remainder = 0;
    } else if (index >= this.stepCount) {
      index = this.stepCount - 1;
      remainder = this.period;
    } else {
      remainder = timeInMs % this.period;
    }
    const t = this.#remainderToT(remainder);
    return { index, t };
  }
}

class FourierBase {
  readonly samples: readonly Complex[];
  readonly terms: FourierTerm[];
  constructor(readonly pathString: string) {
    this.samples = samplesFromPath(pathString, numberOfFourierSamples);
    this.terms = samplesToFourier(this.samples);
    this.keyframes = initializedArray(21, (n) => n);
  }
  keyframes: number[];
  bins() {
    const result = new Array<FourierTerm[]>();
    this.keyframes.forEach((termEndIndex, binEndIndex, keyframes) => {
      const binStartIndex = binEndIndex - 1;
      if (binStartIndex >= 0) {
        const termStartIndex = keyframes[binStartIndex];
        const bin = this.terms.slice(termStartIndex, termEndIndex);
        result.push(bin);
      }
    });
    return result;
  }
  get stepCount() {
    return this.keyframes.length - 1;
  }
  makeGetPath1(timer: Timer): (timeInMs: number) => string {
    const getPath2 = this.makeGetPath2();
    function getPath1(timeInMs: number) {
      const { index, t } = timer.get(timeInMs);
      const pathString = getPath2(index, t);
      return pathString;
    }
    return getPath1;
  }
  makeGetPath2(): (index: number, t: number) => string {
    const terms = [...this.terms];
    const toShow = [...this.keyframes];
    const stepCount = this.stepCount;
    /**
     * Special case:  A dot is moving.
     *    Going from 0 terms to 1 term with frequency = zero.
     *    Don't even think about the animation that we do in other places.
     *    This script is completely unique.
     *    Draw a single line for the path.
     *    Both ends start at the first point.
     *    Use makeEasing() to move the points smoothly.
     */
    const getMaxFrequency = (numberOfTerms: number) => {
      const maxFrequency = Math.max(
        ...terms.slice(0, numberOfTerms).map((term) => Math.abs(term.frequency))
      );
      return maxFrequency;
    };
    const recommendedNumberOfSegments = (numberOfTerms: number) => {
      if (numberOfTerms == 0) {
        return 8;
      } else {
        const maxFrequency = getMaxFrequency(numberOfTerms);
        return 8 * Math.min(maxFrequency, 50) + 7;
      }
    };
    const segmentInfo = initializedArray(stepCount, (index) => {
      const startingTermCount = toShow[index];
      const endingTermCount = toShow[index + 1];
      if (
        startingTermCount == 0 &&
        endingTermCount == 1 &&
        terms[0].frequency == 0
      ) {
        // Moving a dot.
        const goal = assertNonNullable(hasFixedContribution(terms[0]));
        /**
         * @param t A value between 0 and 1.
         * @returns The coordinates as a string.
         */
        function location(t: number) {
          return `${goal.x * t},${goal.y * t}`;
        }
        const getLeadingProgress = makeEasing(0, 0.5);
        const getTrailingProgress = makeEasing(0, 1);
        return (t: number) => {
          const trailingProgress = getTrailingProgress(t);
          const from = location(trailingProgress);
          const leadingProgress = getLeadingProgress(t);
          const to = location(leadingProgress);
          const pathString = `M ${from} L ${to}`;
          // console.log({ t, trailingProgress, leadingProgress, pathString });
          return pathString;
        };
      } else if (startingTermCount == endingTermCount) {
        const parametricFunction = termsToParametricFunction(
          terms,
          startingTermCount
        );
        const numberOfDisplaySegments =
          recommendedNumberOfSegments(endingTermCount);
        const path = PathShape.glitchFreeParametric(
          parametricFunction,
          numberOfDisplaySegments
        );
        const result = path.rawPath;
        return (_timeInMs: number): string => {
          return result;
        };
      } else {
        // TODO this should probably be the largest from the group that we are adding.
        const firstInterestingFrequency = Math.abs(
          terms[startingTermCount].frequency
        );
        const r = 0.2 / firstInterestingFrequency;
        /**
         * This creates a function which takes a time in milliseconds,
         * 0 at the beginning of the script.
         * The output is scaled to the range 0 - 1,
         * for use with PathShape.parametric().
         * The output might be outside of that range.
         * I.e. the input and output are both numbers but they are interpreted on different scales.
         */
        const tToCenter = makeBoundedLinear(0, -r, 1, 1 + r);
        const startingFunction = termsToParametricFunction(
          terms,
          startingTermCount
        );
        const addingFunction = termsToParametricFunction(
          terms,
          endingTermCount - startingTermCount,
          startingTermCount
        );
        const numberOfDisplaySegments =
          recommendedNumberOfSegments(endingTermCount);
        if (
          startingTermCount == 0 ||
          (startingTermCount == 1 && hasFixedContribution(terms[0]))
        ) {
          // We are converting from a dot to something else.
          const startingPoint = hasFixedContribution(terms[0]) ?? {
            x: 0,
            y: 0,
          };
          return (timeInMs: number): string => {
            const centerOfChange = tToCenter(timeInMs);
            const startOfChange = centerOfChange - r;
            const endOfChange = centerOfChange + r;
            const getFraction = makeEasing(startOfChange, endOfChange);
            /**
             * 0 to `safePartEnds`, inclusive are safe inputs to `parametricFunction()`.
             */
            const safePartEnds = Math.min(1, endOfChange);
            if (safePartEnds <= 0) {
              // There is no safe part!
              return `M${startingPoint.x},${startingPoint.y} L${startingPoint.x},${startingPoint.y}`;
            } else {
              const frugalSegmentCount = Math.ceil(
                // TODO that 150 is crude.  The transition might require
                // more detail than the before or the after.
                // Or it might require less, not that we are glitch-free.
                Math.max(numberOfDisplaySegments, 150) * safePartEnds
              );
              function parametricFunction(t: number) {
                t = t * safePartEnds;
                const base = startingFunction(t);
                const fraction = 1 - getFraction(t);
                if (fraction == 0) {
                  return base;
                } else {
                  const adding = addingFunction(t);
                  return {
                    x: base.x + fraction * adding.x,
                    y: base.y + fraction * adding.y,
                  };
                }
              }
              const path = PathShape.glitchFreeParametric(
                parametricFunction,
                frugalSegmentCount
              );
              return path.rawPath;
            }
          };
        } else {
          // Common case:  Converting from one normal shape into another.
          return (timeInMs: number): string => {
            const centerOfChange = tToCenter(timeInMs);
            const getFraction = makeEasing(
              centerOfChange - r,
              centerOfChange + r
            );
            function parametricFunction(t: number) {
              const base = startingFunction(t);
              const fraction = 1 - getFraction(t);
              if (fraction == 0) {
                return base;
              } else {
                const adding = addingFunction(t);
                return {
                  x: base.x + fraction * adding.x,
                  y: base.y + fraction * adding.y,
                };
              }
            }
            const path = PathShape.glitchFreeParametric(
              parametricFunction,
              numberOfDisplaySegments
            );
            return path.rawPath;
          };
        }
      }
    });
    function getPath2(index: number, t: number) {
      const info = segmentInfo[index];
      return info(t);
    }
    return getPath2;
  }
}

class FourierAnimation {
  hide() {
    this.#destination.hide();
  }
  readonly #showPath: (timeInMs: number) => void;
  show(timeInMs: number) {
    this.#destination.show(this.#referenceColor, this.#liveColor);
    this.#destination.setReferencePath(this.#pathString);
    this.#destination.setTransform(this.#transform);
    this.#showPath(timeInMs);
  }
  readonly timer: Timer;
  readonly #pathString: string;
  readonly #destination: Destination;
  readonly #referenceColor: string;
  readonly #liveColor: string;
  readonly #transform: DOMMatrix;
  readonly base: FourierBase;
  static readonly PERIOD = 7000;
  static readonly PAUSE = 1000;
  constructor(options: Options) {
    this.base = options.base;
    this.#pathString = options.base.pathString;
    this.#destination = options.destination;
    this.#referenceColor = options.referenceColor;
    this.#liveColor = options.liveColor;
    pathCaliper.d = this.#pathString;
    this.#transform = this.#destination.getTransform(pathCaliper.getBBox());
    this.timer = new Timer(
      options.base.stepCount,
      FourierAnimation.PERIOD,
      FourierAnimation.PAUSE
    );
    const getPath = options.base.makeGetPath1(this.timer);
    this.#showPath = (timeInMs: number) => {
      const pathString = getPath(timeInMs);
      this.#destination.setLivePath(pathString);
    };
  }
}


  const colorPairs = [
    { light: "var(--pastel-blue)", dark: "var(--darker-blue)" },
    { light: "var(--pastel-lavender)", dark: "var(--darker-purple)" },
    { light: "var(--pastel-pink)", dark: "var(--darker-pink)" },
    { light: "var(--pastel-mint)", dark: "var(--darker-teal)" },
    { light: "var(--pastel-coral)", dark: "var(--darker-coral)" },
  ];

  const random = Random.fromString("fourier-.ts");
  const colorsByIndex = initializedArray(allPaths.length, () => {
    const index = (random() * 3) | 0;
    const thisTime = colorPairs[index];
    colorPairs.splice(index, 1);
    colorPairs.push(thisTime);
    return thisTime;
  });
  colorsByIndex;

  // const requestedIndex = parseIntX(
  //   new URLSearchParams(window.location.search).get("index")
  // );
  // const index = requestedIndex ?? (Math.random() * allPaths.length) | 0;

  // colorsByIndex[index];
  // const colors = { light: "var(--pastel-pink)", dark: "var(--darker-pink)" };
  // console.log({ requestedIndex, index, path, ...colors });
  // console.log(allPaths);

  //let colorIndex = 7;

  let todaysIndex = 64;

  // MARK: Locations

  function circle(r: number, cx: number, cy: number): ReadOnlyRect {
    const x = cx - r;
    const y = cy - r;
    const width = 2 * r;
    const height = 2 * r;
    return { x, y, width, height };
  }

  const unit = 9 / 4;
  const clientPortion = 0.65;

  const baseInfo: {
    color: string;
    destRect: ReadOnlyRect;
    index: number;
    search?: string;
  }[] = [
    {
      color: "n/a",
      destRect: circle(2, 11.5, 2.5),
      index: todaysIndex,
    },
    {
      color: "n/a",
      destRect: circle(2, 4.5, 6.6),
      index: todaysIndex,
    },
  ];
  const layoutInfo = {
    radius: unit * clientPortion,
    cx: [
      unit,
      (unit + 16 / 2) / 2,
      16 / 2,
      (16 - unit + 16 / 2) / 2,
      16 - unit,
    ],
    cy: [9 - 2.75 * unit, 2.75 * unit],
  };
  console.log(layoutInfo);

  function showIndex(
    index: number,
    where: SVGTextElement | string = ".chapter"
  ) {
    if (typeof where === "string") {
      where = querySelector(where, SVGTextElement);
    }
    where.innerHTML = `#${index} of ${ShapeMaker6.allPaths.length}`;
  }
  showIndex;

  const fourierInfo = baseInfo.map(({ index }) => {
    const pathString = ShapeMaker6.makePathShape(index).rawPath;
    return new FourierBase(pathString);
  });

  // MARK: Group multiple different ones
  if (false) {
    //fourierInfo[1].terms.forEach((term) => (term.frequency = -term.frequency));
    /**
     * For each frequency, list the amplitudes of that frequency used by all three curves.
     * So we can make make decisions for all three curves at once.
     */
    const amplitudes = new Map<number, number[]>();
    fourierInfo.forEach((base) =>
      base.terms.forEach(({ frequency, amplitude }) => {
        let amplitudesForThisFrequency = amplitudes.get(frequency);
        if (!amplitudesForThisFrequency) {
          amplitudesForThisFrequency = new Array<number>();
          amplitudes.set(frequency, amplitudesForThisFrequency);
        }
        amplitudesForThisFrequency.push(amplitude);
      })
    );
    /**
     * Now sort the records so we can see which frequencies have the most total amplitude.
     * We usually like to display the highest amplitude changes first.
     */
    const amplitudes1 = Array.from(
      amplitudes.entries(),
      ([frequency, amplitudes]) => ({
        frequency,
        amplitude: amplitudes.sort((a, b) => a - b)[2] ?? 0,
      })
    );
    amplitudes1.sort((a, b) => b.amplitude - a.amplitude);
    // This first attempt just kept the 10 highest values
    // before letting each curve go off on it's own.
    // It worked well even when we stopped here.
    //amplitudes1.splice(10, numberOfFourierSamples);
    /**
     * The first phase continues until I can't find any more terms with enough amplitude
     * to care about.  I (arbitrarily) set the cutoff at 1/20 of the highest amplitude.
     */
    const amplitudeCutoff = amplitudes1[0].amplitude * 0.05;
    /**
     * These are the frequencies that we want to start with.
     * First display all of these, in order.
     * Then each curve can return to its own list.
     */
    const amplitudes2 = amplitudes1
      .filter(({ amplitude }) => amplitude > amplitudeCutoff)
      .slice(0, 6);
    console.log(amplitudes2);

    /**
     * Go through each animation.
     * Reorder the terms to match the list that we created above.
     */
    fourierInfo.forEach(({ terms, keyframes }, index) => {
      const bins: FourierTerm[][] = [];
      // Move the common terms to the front.
      amplitudes2.forEach(({ frequency }, _desiredIndex) => {
        const initialIndex = terms.findIndex(
          (term) => term.frequency == frequency
        );
        if (initialIndex == -1) {
          bins.push([{ amplitude: 0, phase: 0, frequency }]);
        } else {
          bins.push(terms.splice(initialIndex, 1));
        }
      });
      // Group the remaining items into bins.
      const desiredBinCount = 11;
      while (bins.length < desiredBinCount - 1) {
        let binSize: number;
        if (bins.length < 6) {
          binSize = 1;
        } else if (bins.length < 10) {
          binSize = 3;
        } else {
          binSize = 10;
        }
        const big = terms.splice(0, binSize);
        if (big.length != binSize) {
          throw new Error("wtf");
        }
        bins.push(big);
      }
      // Make one big group and add it right after the common part.
      let bigGroupIndex: number;
      switch (index) {
        case 0:
        case 4: {
          bigGroupIndex = amplitudes2.length + 1;
          break;
        }
        case 1:
        case 3: {
          bigGroupIndex = amplitudes2.length + 2;
          break;
        }
        case 2: {
          bigGroupIndex = amplitudes2.length + 3;
          break;
        }
        default: {
          throw new Error("wtf");
        }
      }
      bigGroupIndex = bins.length - 1;
      bins.splice(bigGroupIndex, 0, [...terms]);
      if (bins.length != desiredBinCount) {
        throw new Error("wtf");
      }
      // Move two big-ish ones all the way to the end.
      const newLastItems = bins.splice(2, 2);
      bins.push(...newLastItems);
      if (bins.length != desiredBinCount) {
        throw new Error("wtf");
      }
      // Move a smallish one toward the front
      const smallish = bins.splice(6, 1);
      bins.splice(2, 0, ...smallish);
      if (bins.length != desiredBinCount) {
        throw new Error("wtf");
      }
      bins.splice(0, 0, ...initializedArray(index, () => []));
      bins.splice(
        Number.MAX_SAFE_INTEGER,
        0,
        ...initializedArray(4 - index, () => [])
      );
      console.log(bins);
      terms.length = 0;
      keyframes.length = 0;
      keyframes.push(0);
      bins.forEach((bin) => {
        terms.push(...bin);
        keyframes.push(terms.length);
      });
      // if (terms.length != originalNumberOfTerms) {
      //   throw new Error("wtf");
      // }
    });
  }

  // MARK: Forward and back
  if (true) {
    /**
     * Go through each animation.
     * Reorder the terms to match the list that we created above.
     */
    fourierInfo.forEach(({ terms, keyframes }, _index) => {
      const originalNumberOfTerms = terms.length;
      const normalBins: FourierTerm[][] = [];
      // Move the common terms to the front.
      const desiredBinCount = 7; //10;
      while (normalBins.length < desiredBinCount - 1) {
        let binSize: number;
        if (normalBins.length < 6) {
          binSize = 1;
        } else {
          binSize = 3;
        }
        const newBin = terms.splice(0, binSize);
        if (newBin.length != binSize) {
          throw new Error("wtf");
        }
        normalBins.push(newBin);
      }
      // Rearrange all the normal bins.  The first two remain first, and the third one goes to the end.
      // The fourth and fifth go right after the first and second and the sixth goes right before the third.
      // Continue for all normal bins.
      const beginning: FourierTerm[][] = [];
      const end: FourierTerm[][] = [];
      normalBins.forEach((bin, originalIndex) => {
        if (originalIndex % 3 < 2) {
          beginning.push(bin);
        } else {
          end.unshift(bin);
        }
      });
      // Make one bin from the remaining terms and add it right between the beginning and end.
      const bins: FourierTerm[][] = [...beginning, [...terms], ...end];
      if (bins.length != desiredBinCount) {
        throw new Error("wtf");
      }
      /*
      bins.splice(0, 0, ...initializedArray(index, () => []));
      bins.splice(
        Number.MAX_SAFE_INTEGER,
        0,
        ...initializedArray(4 - index, () => [])
      );
      */
      console.log(bins);
      terms.length = 0;
      keyframes.length = 0;
      keyframes.push(0);
      bins.forEach((bin, _index, _array) => {
        terms.push(...bin);
        keyframes.push(terms.length);
      });
      if (terms.length != originalNumberOfTerms) {
        throw new Error("wtf");
      }
    });
  }

  // MARK: reorderForSymmetry()
  function reorderForSymmetry(
    terms: FourierTerm[],
    desiredFrequency: number,
    direction: 1 | -1
  ) {
    terms.sort((a, b) => b.amplitude - a.amplitude);
    const front = new Array<FourierTerm>();
    const back = new Array<FourierTerm>();
    let amplitudeCutoff: undefined | number;
    terms.forEach((term) => {
      if (amplitudeCutoff !== undefined && term.amplitude < amplitudeCutoff) {
        back.push(term);
      } else if ((term.frequency + direction) % desiredFrequency == 0) {
        front.push(term);
        if (amplitudeCutoff === undefined) {
          amplitudeCutoff = term.amplitude * 0.05;
        }
      } else {
        back.push(term);
      }
    });
    terms.length = 0;
    terms.push(...front, ...back);
    console.log(front, back, terms);
    return { frontLength: front.length };
  }
  if (false) {
    reorderForSymmetry(fourierInfo[0].terms, 4, -1); // 4,-1
    reorderForSymmetry(fourierInfo[1].terms, 4, -1); //3,-1. better 4,+1 or 4,-1
    reorderForSymmetry(fourierInfo[2].terms, 5, -1); //2,+1. better 3,+1 or 5,-1
  }

  console.log(fourierInfo);

  // MARK: holdBackThree()
  /**
   * This was a nice way to make 8 related animations from the same base.
   *
   * It reserves 3 terms that it can control.
   * Half of the instances get the first term near the beginning, others will just sit and wait.
   * Next, half of the instances get the second term, but half chosen a different way.
   * Then the third half git the third term.
   * Use binary so each of 8 terms can get a different subset of the original three terms.
   * Near the end we revisit the first of these special terms.
   * Instances that already included this term sit quietly while the other instances add this term.
   * Then the second of the special terms.
   * Then the same for the third.
   *
   * Other terms are grouped and arranged to make things look good.
   * This was based on moveSmallOnesToTheFront().
   * @param fourierBase This will be modified.
   * @param which 0 through 7, inclusive.
   * When I only had 7 instances I chose to skip 0 and use 1 though 7.
   */
  function holdBackThree(fourierBase: FourierBase, which = 0) {
    if (which == 0) {
      console.table(fourierBase.terms.slice(0, 20));
    }
    const bins: FourierTerm[][] = [];
    const terms = fourierBase.terms;
    const numberOfTerms = terms.length;
    const smallTermsBinIndex = 7;
    const desiredBinCount = 14;
    const special = terms.splice(3, 3);
    const finalBins: typeof bins = [];
    special.forEach((term, index) => {
      const present = (which & (2 ** index)) > 0;
      if (present) {
        bins.push([term]);
        finalBins.push([]);
      } else {
        bins.push([]);
        finalBins.push([term]);
      }
    });
    while (bins.length < desiredBinCount - 1 - finalBins.length) {
      let binSize: number;
      if (bins.length < 6) {
        binSize = 1;
      } else if (bins.length < 8) {
        binSize = 2;
      } else {
        binSize = 3;
      }
      const big = terms.splice(0, binSize);
      if (big.length != binSize) {
        throw new Error("wtf");
      }
      bins.push(big);
    }
    // Move a big term, one of the first first terms to the front, right before the separation.
    const bigTerm = bins.splice(5, 1)[0];
    bins.splice(0, 0, bigTerm);
    /*
    for (let i = 1; i < bins.length; i++) {
      const binsRemaining = bins.length - i - 1;
      const itemsRemaining = terms.length;
      const itemsThisTime = Math.round(itemsRemaining / binsRemaining);
      bins[i].push(...terms.splice(0, itemsThisTime));
    }
    */
    bins.splice(smallTermsBinIndex, 0, [...terms]);
    bins.push(...finalBins);
    console.log(bins);
    if (bins.length != desiredBinCount) {
      throw new Error("wtf");
    }
    terms.length = 0;
    if (terms.length != 0) {
      throw new Error("wtf");
    }
    const keyframes = fourierBase.keyframes;
    keyframes.length = 0;
    keyframes.push(0);
    bins.forEach((bin) => {
      terms.push(...bin);
      keyframes.push(terms.length);
    });
    if (terms.length != numberOfTerms) {
      throw new Error("wtf");
    }
  }
  holdBackThree;

  // MARK: moveSmallOnesToTheFront()
  function moveSmallOnesToTheFront(fourierBase: FourierBase, which = 0) {
    if (which == 0) {
      console.table(fourierBase.terms.slice(0, 20));
    }
    const bins: FourierTerm[][] = [];
    const terms = fourierBase.terms;
    const numberOfTerms = terms.length;
    const smallTermsBinIndex = 3 + 2 * which;
    const desiredBinCount = 12;
    while (bins.length < desiredBinCount - 1) {
      let binSize: number;
      if (bins.length < 6) {
        binSize = 1;
      } else if (bins.length < 8) {
        binSize = 2;
      } else {
        binSize = 5;
      }
      const big = terms.splice(0, binSize);
      if (big.length != binSize) {
        throw new Error("wtf");
      }
      bins.push(big);
    }
    // Move a big term, one of the first first terms to the front, right before the separation.
    //const bigTerm = bins.splice(5, 1)[0];
    //bins.splice(0, 0, bigTerm);
    /*
    for (let i = 1; i < bins.length; i++) {
      const binsRemaining = bins.length - i - 1;
      const itemsRemaining = terms.length;
      const itemsThisTime = Math.round(itemsRemaining / binsRemaining);
      bins[i].push(...terms.splice(0, itemsThisTime));
    }
    */
    bins.splice(smallTermsBinIndex, 0, [...terms]);
    console.log(bins);
    if (bins.length != desiredBinCount) {
      throw new Error("wtf");
    }
    terms.length = 0;
    if (terms.length != 0) {
      throw new Error("wtf");
    }
    const keyframes = fourierBase.keyframes;
    keyframes.length = 0;
    keyframes.push(0);
    bins.forEach((bin) => {
      terms.push(...bin);
      keyframes.push(terms.length);
    });
    if (terms.length != numberOfTerms) {
      throw new Error("wtf");
    }
  }
  if (false) {
    fourierInfo.forEach((f, index) => {
      moveSmallOnesToTheFront(f, index);
    });
  }

  const animations = new Array<Showable>();
  const foregroundG = querySelector("g#foreground", SVGGElement);
  const altColorPairs: {
    light: string;
    dark: string;
  }[] = [
    { light: "Magenta", dark: "black" },
    { light: "Magenta", dark: "black" },
    { light: "HotPink", dark: "red" },
    { light: "white", dark: "gray" },
    { light: "var(--blue)", dark: "blue" },
    { light: "orange", dark: "darkOrange" },
    { light: "Fuchsia ", dark: "DarkViolet" },
  ];
  const lastIndex = baseInfo.length - 1;
  for (const [base, fourier, { light, dark }, index] of zip(
    baseInfo,
    fourierInfo,
    altColorPairs,
    count()
  )) {
    const { destRect, search } = base;
    const frequenciesG =
      search === undefined
        ? document.createElementNS("http://www.w3.org/2000/svg", "g")
        : querySelector(
            `g.frequencies[data-frequencies="${search}"]`,
            SVGGElement
          );
    const top =
      search === undefined
        ? foregroundG.appendChild(
            assertClass(
              querySelector("defs g[data-fourier-top]", SVGGElement).cloneNode(
                true
              ),
              SVGGElement
            )
          )
        : querySelector(`[data-fourier-top="${search}"]`, SVGGElement);
    top.style.setProperty("--color", light);
    top.style.setProperty("--blur-color", dark);
    const destination = new Destination(top, (content: ReadOnlyRect) =>
      panAndZoom(content, destRect, "srcRect fits completely into destRect")
    );
    // This might be the easiest way to find an item later.
    // i.e. [data-live-index="2"] as a css selector to find the third item.
    top.dataset.liveIndex = index.toString();
    frequenciesG.style.fill = dark;
    const options = {
      base: fourier,
      destination: destination,
      liveColor: dark,
      referenceColor: light,
    };
    const fourierAnimation = new FourierAnimation(options);
    //fourierAnimation.show(10000)
    animations.push(fourierAnimation);
    console.log(fourierAnimation);
  }

  {
    const canvas = getById("cga", HTMLCanvasElement);
    // Background:
    const context = canvas.getContext("2d")!;
    // Map to 16x9
    // But the edges will be cut off, it's really 12x9
    // But the middle 12.
    // Note that we are explicitly not maintaining the aspect ratio.
    // Old pixels weren't square.
    const srcRect: ReadOnlyRect = { x: 2, y: 0, width: 12, height: 9 };
    const destRect: ReadOnlyRect = {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
    };
    const baseTransform = rectToRect(srcRect, destRect);
    const baseTransformMatrix = new DOMMatrix(baseTransform.transformString);
    function resetBackground() {
      context.reset();
      context.fillStyle = "cyan";
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    const mainSVG = getById("main", SVGSVGElement);
    const mainPaths = querySelectorAll(
      "[data-live-index] path.main",
      SVGPathElement
    );
    const shadowPaths = querySelectorAll(
      "[data-live-index] path.offset-blur",
      SVGPathElement
    );
    /*
    // Shadow:
    context.fillStyle = "white";
    context.filter = "url(#checkerboard-alpha)";
    context.beginPath();
    context.ellipse(8.25, 4.75, 4, 4, 0, 0, FULL_CIRCLE, false);
    context.fill();
    //context.fillRect(0, 0, canvas.width, canvas.height);
    // Foreground:
    context.fillStyle = "magenta";
    context.filter = "url(#anti-anti-alias)";
    context.beginPath();
    context.ellipse(8, 4.5, 4, 4, 0, 0, FULL_CIRCLE, false);
    context.fill();
    */
    const font = resizeFont(roundCursiveFont, 2);
    const textLayout = new TextLayout(font);
    const layoutInfo: LetterLayoutInfo[] = [];
    layoutInfo.push(...textLayout.addText("Party", "left"));
    textLayout.carriageReturn();
    textLayout.lineFeed();
    layoutInfo.push(...textLayout.addText(" like it’s"));
    textLayout.carriageReturn();
    textLayout.lineFeed();
    layoutInfo.push(...textLayout.addText("  1983."));
    const down = 1;
    const left = 2.2;
    let fullPathShape = PathShape.join(
      layoutInfo.map((letter) => ({
        shape: letter.description.shape,
        Δx: letter.x + left,
        Δy: letter.baseline + down,
      }))
    );
    const lineTextParent = getById("line-text", SVGGElement);
    const textElement = fullPathShape.makeElement(false);
    lineTextParent.append(textElement);

    const clipPathAnimation = canvas.animate(
      [
        {
          clipPath: "rect(0% 100% 100% 0%)",
          offset: 0,
        },
        {
          clipPath: "rect(0% 100% 100% 100%)",
          offset: 0.5,
        },
        {
          clipPath: "rect(0% 0% 100% 0%)",
          offset: 0.5,
        },
        {
          clipPath: "rect(0% 100% 100% 0%)",
          offset: 1,
        },
      ],
      { duration: 9897, iterations: Infinity }
    );
    clipPathAnimation.pause();

    function show(timeInMS: number) {
      clipPathAnimation.currentTime = timeInMS;

      function showPath(from: SVGPathElement) {
        const d = assertNonNullable(from.getAttribute("d"));
        const path = new Path2D(d);
        const style = getComputedStyle(from);
        const strokeWidth = style.strokeWidth;
        const lineWidth = assertNonNullable(
          parseFloatX(/^(.*)px$/.exec(strokeWidth)![1])
        );
        context.lineWidth = lineWidth;
        context.lineCap = style.strokeLinecap as any;
        context.lineJoin = style.strokeLinejoin as any;
        // rehome can't be done in advance.  gave me the identity matrix for both when I tried.
        // presumably getCTM() fails, but I didn't check.
        const rehomed = rehome(from, mainSVG);
        const transform = baseTransformMatrix.multiply(rehomed);
        // I expect the final circle to fit in this rectangle perfectly.
        context.setTransform(transform);
        context.stroke(path);
      }
      resetBackground();
      context.strokeStyle = "white";
      context.filter = "url(#anti-anti-alias)";
      showPath(textElement);
      context.strokeStyle = "black";
      context.filter = "url(#checkerboard-alpha)";
      shadowPaths.forEach((shadowPath) => {
        showPath(shadowPath);
      });
      context.strokeStyle = "magenta";
      context.filter = "url(#anti-anti-alias)";
      mainPaths.forEach((mainPath) => {
        showPath(mainPath);
      });
    }
    animations.push({ show });
  }

  /**
   *
   * @param options
   * @returns A list of 5 spinner objects.
   * The first in the list is on the top of the z-order.
   * The colors come from the list of pastels.
   */
  function make5(options: {
    centerX: number;
    centerY: number;
    radius: number;
  }) {
    return colorPairs
      .map(({ dark }) => new MotionBlurSpinner({ ...options, color: dark }))
      .reverse();
  }

  if (false) {
    // MARK: 10 Frequency Spinners.
    const radius = layoutInfo.radius / 4;
    const cx = layoutInfo.cx;
    const cy = layoutInfo.cy;
    const yOffset = radius * 1.5;
    const binsOfSpinners: MotionBlurSpinner[][] = [];
    [-1, +1].forEach((row) => {
      const centerY = cy[0] + row * yOffset;
      [cx[0], cx[2], cx[4]].forEach((centerX) => {
        binsOfSpinners.push(make5({ centerX, centerY, radius }));
      });
    });
    [-1, +1].forEach((row) => {
      const centerY = cy[1] + row * yOffset;
      [cx[1], cx[3]].forEach((centerX) => {
        binsOfSpinners.push(make5({ centerX, centerY, radius }));
      });
    });
    if (binsOfSpinners.length != 10) {
      throw new Error("wtf");
    }
    const fullAnimation = assertClass(animations[0], FourierAnimation);
    const timer = fullAnimation.timer;
    const bins = fullAnimation.base.bins();
    function show(timeInMS: number) {
      const { index, t } = timer.get(timeInMS);
      const cutoff = t >= 1 ? -1 : index;
      const progressInRadians = t * FULL_CIRCLE;
      for (const [bin, spinners, index] of zip(bins, binsOfSpinners, count())) {
        if (index > cutoff) {
          spinners.forEach((spinner) => {
            spinner.hide();
          });
        } else {
          for (const [term, spinner] of zip(bin, spinners)) {
            const angleToDisplay =
              progressInRadians * term.frequency + term.phase;
            spinner.showRadians(angleToDisplay);
          }
        }
      }
    }
    animations.push({ show });
  }

  if (false) {
    // MARK: New Frequency Spinners.
    const fullAnimation = assertClass(animations[0], FourierAnimation);
    const timer = fullAnimation.timer;
    const bins = fullAnimation.base.bins();
    type Info = { term: FourierTerm; startIndex: number };
    const smallGroupInfo = new Array<Info>();
    const largeGroupInfo = new Array<Info>();
    bins.forEach((terms, startIndex) => {
      const target = terms.length < 7 ? smallGroupInfo : largeGroupInfo;
      terms.forEach((term) => {
        target.push({ term, startIndex });
      });
    });
    [smallGroupInfo, largeGroupInfo].forEach((infoList) => {
      infoList.sort(
        (a, b) => Math.abs(a.term.frequency) - Math.abs(b.term.frequency)
      );
    });
    console.log({ smallGroupInfo, largeGroupInfo });
    // Expecting about 21 terms in smallGroupInfo
    // and 1003 terms in largeGroupInfo
    const smallGroupSpinners = [
      { centerX: 2, centerY: 2, radius: 1 },
      { centerX: 5, centerY: 2, radius: 1 },
      { centerX: 8, centerY: 2, radius: 1 },
      { centerX: 11, centerY: 2, radius: 1 },
      { centerX: 14, centerY: 2, radius: 1 },
    ].map((options) => make5(options));
    const largeGroupSpinners: typeof smallGroupSpinners = [];
    {
      const left = 6 - 0.5;
      const right = 16 - 0.25;
      const across = 7;
      const xIncrement = (right - left) / across;
      const top = 4 - 0.5;
      const bottom = 9 - 0.25;
      const down = 3;
      const yIncrement = (bottom - top) / down;
      for (let y = 0; y < down; y++) {
        for (let x = 0; x < across; x++) {
          const centerX = left + (x + 0.5) * xIncrement;
          const centerY = top + (y + 0.5) * yIncrement;
          const radius = 1 / 3;
          const options = { centerX, centerY, radius };
          const spinners = make5(options);
          largeGroupSpinners.push(spinners);
        }
      }
    }
    function spinnersInOrder(
      asGroups: MotionBlurSpinner[][]
    ): MotionBlurSpinner[] {
      const result = new Array<MotionBlurSpinner>();
      while (true) {
        const donarGroup = asGroups.shift();
        if (!donarGroup) {
          break;
        }
        const nextSpinner = donarGroup.shift();
        if (nextSpinner) {
          result.push(nextSpinner);
          asGroups.push(donarGroup);
        }
      }
      return result;
    }
    const runnable = new Array<{
      term: FourierTerm;
      spinner: MotionBlurSpinner;
      startIndex: number;
    }>();
    for (const [{ term, startIndex }, spinner] of zip(
      smallGroupInfo,
      spinnersInOrder(smallGroupSpinners)
    )) {
      runnable.push({ term, spinner, startIndex });
    }
    for (const [{ term, startIndex }, spinner] of zip(
      largeGroupInfo,
      spinnersInOrder(largeGroupSpinners)
    )) {
      runnable.push({ term, spinner, startIndex });
    }

    if (false) {
      //test it
      runnable.forEach(({ term, spinner }) => {
        spinner.showRadians(term.phase);
      });
    }
    function show(timeInMS: number) {
      const { index, t } = timer.get(timeInMS);
      const cutoff = t >= 1 ? -1 : index;
      const progressInRadians = t * FULL_CIRCLE;
      runnable.forEach(({ term, spinner, startIndex }) => {
        if (startIndex > cutoff) {
          spinner.hide();
        } else {
          const angleToDisplay =
            progressInRadians * term.frequency + term.phase;
          spinner.showRadians(angleToDisplay);
        }
      });
    }
    animations.push({ show });
  }

  if (false) {
    // MARK: Frequency Spinners.
    // TODO bins class.
    //   Extract it from moveSmallOnesToTheFront().
    const frequencySpinners = new FrequencySpinners('[data-frequencies="red"]');
    /**
     * This is full because at the beginning we add all three of the optional terms.
     * That means, at the end we add none of the optional terms.
     */
    const fullAnimation = assertClass(animations.at(2), FourierAnimation);
    const timer = fullAnimation.timer;

    const bins = fullAnimation.base.bins();
    console.log(bins);
    function show(timeInMS: number) {
      const { index, t } = timer.get(timeInMS);
      if (t >= 1) {
        frequencySpinners.show([], 0);
      } else {
        frequencySpinners.show(bins[index], t * FULL_CIRCLE);
      }
    }
    animations.push({ show });
  }

  console.log(animations);
  initialize(...animations);

